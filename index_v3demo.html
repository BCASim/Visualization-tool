<!DOCTYPE html>
<!--
    version_3
    扱えるイベントの種類を変更
-->

<script>
    var matrix_filename = "./outputFile/adjacencyMatrix.csv";
    var blockchain_filename = "./outputFile/block.json";
    var event_filename = "./outputFile/event.json";
    //var matrix_filename = "./input/adjacencyMatrix.csv";
    //var blockchain_filename = "./input/block.json";
    //var event_filename = "./input/event.json";
</script>
<html>

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="content-language" content="ja">
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="./style_demo.css">
        <title>BCASim Visualization System</title>
    </head>

    <body>
        
        <center><span id="TimestampArea">The simulation time is displayed here</span></center>
   
        <div id="parent">
            <div id="mynetwork"></div>
            <div id="myblockchain">
                
            </div>
        </div>

    </body>

    <!--<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.15.0/vis.js"></script>-->

    <script src="./js/vis.js"></script>
    <script src="./js/jquery-3.1.0.min.js"></script>

    <!-------------------------入力ファイルの読み込み部分--------------------------->
    <script>

        /*ファイルデータを保存*/
        var blockchain_data;
        var event_data;
        var matrix_data;

        /*ファイルの読み込み*/
        function input_data(){

            $(function() {
                $.getJSON(event_filename, function(data) {
                    event_data = data
                })
            });
            $(function() {
                $.getJSON(blockchain_filename, function(data) {
                    blockchain_data = data
                })
            });

            
            getCSVFile();    
        }


        /*csvファイルの読み込み処理*/
        function getCSVFile() {
            var xhr = new XMLHttpRequest();
            xhr.onload = function() {
                createArray(xhr.responseText);
            };
            xhr.open("get", matrix_filename , true);
            xhr.send(null);
        }

        function createXMLHttpRequest() {
            var XMLhttpObject = null;
            XMLhttpObject = new XMLHttpRequest();
            return XMLhttpObject;
        }
        
        function createArray(csvData) {
            var tempArray = csvData.split("\n");
            var csvArray = new Array();
            for(var i = 0; i<tempArray.length;i++){
                csvArray[i] = tempArray[i].split(",");
            }
            matrix_data = csvArray;
            
            main();
            
        }

    </script>


    <!----------------------------------ブロックチェーン部分------------------------------------->
    <script>
        var nodes_block = new vis.DataSet([]);
        var edges_block = new vis.DataSet([]);
        var container_block = document.getElementById('myblockchain');
        var block_list_id = [];
        var block_list_hash = [];
        var block_index = 0;
        
        var data_block = {
            nodes: nodes_block,
            edges: edges_block
        };

        var options_block = {
            nodes: {
                shape: "box",
                size: 26,
            },
            layout: {
                hierarchical: {
                    //direction: "LR", 
                    sortMethod: "directed",
                }
            }
        };


        b_color = [];
        /*チェーンに次のブロックを追加して表示する*/
        function next_block(){
            if(block_index==0){
                nodes_block.add({id: 0, label: 0+"\ngenesis",group:0});
                block_list_hash.push(blockchain_data[0].hash);
                block_index++;
                return;
            }

            for(i=0;i<block_list_hash.length;i++){
                if(blockchain_data[block_index].previousHash==block_list_hash[i]){
                    block_list_hash.push(blockchain_data[block_index].hash);
                    _miner = blockchain_data[block_index].miner;
                    _height = blockchain_data[block_index].height;
                    
                    
                    
                    nodes_block.add({id: block_index, label: _height+"\nnode"+_miner, group: _miner});
                    edges_block.add({from: i, to: block_index, arrows: "to",width: 3});
                    block_index++;
                    break;
                }
            }
        }
        /*++++++++++++ MAIN（ブロックチェーン処理）++++++++++*/
        var blockchian = new vis.Network(container_block, data_block, options_block);

    </script>
    
    
    <!-----------------------------------------ネットワーク部分-------------------------------------------->
    <script>
        //ネットワーク
        nodes = new vis.DataSet([]);
        edges = new vis.DataSet([]);
        var traffic_count = true;
        var traffic_edge = [];
        var traffic_arrow = [];
        var block_id = [];

        var edge_id = 0;
        var event_id = 0;

      

        /*********ノードに関する操作*********/

        /*csvの隣接行列を使用*/
        function add_node(){
            var nc = 1;
            for (var i=0; i<matrix_data[0].length; i++){
                nodes.add([{id:i, label:"node"+i, group: nc}]);
                nc++;
            }
        }


        /*エッジに関連する操作*/
        /*csvの隣接行列を使用*/
        function add_edge(){
            for(var i=0;i<matrix_data[0].length;i++){
                for(var j=i;j<matrix_data[0].length;j++){
                    if(matrix_data[i][j]==1){
                        network.body.data.edges.update([{id:i*matrix_data.length-1+j,from:i, to:j,color :"#848484"}]);
                        edge_id++;
                    }
                }
            }
        }


         //------------------ノードの色変更部分----------------------
        //ブロックに関連する情報
        var hash_lists = [];//ハッシュのリスト
        var color_lists = [];//ブロック番号
        //ノードに関連する情報
        var node_index = [];//ブロック高（ノード）

        //----ブロック発見時の処理----
        function update_node_found(node_id,index,hash){

            //----初期化処理----
            if(node_index.length==0){
                for(i=0;i<matrix_data[0].length;i++){
                    node_index.push(0);
                }
            }

            //----新規ブロックの追加（初期IDは1）
            hash_lists.push(hash)
            color_lists.push(color_lists.length+2);
            
            //ブロック高が最大の場合は追加する
            if(node_index[node_id]<index){
                node_index[node_id] = index;
                /*nodes.update({id:node_id, group: color_lists.length+1});*/
            } 
        }
        
        //----ブロック受信時の処理----
        function update_node_receive(node_id,index,hash){

            //リストからハッシュの探索
            _color = 0;
            for(i=0;i<hash_lists.length;i++){
                if(hash == hash_lists[i]){
                    _color = color_lists[i];
                    break;
                }
            }

            //ノードの色を更新
            if(node_index[node_id]<index){
                node_index[node_id] = index;
                /*nodes.update({id:node_id, group: _color});*/
            } 
        }



         /***********トラフィックの再生************/
        function play_traffic(){
            if (traffic_count){
                traffic_count = false;
                for (var i=0; i<traffic_edge.length;i++){
                    for(var j=i;j<traffic_edge.length;j++){
                        if(traffic_edge[i][j]==1){
                            if(traffic_arrow[i][j]==0){
                                network.body.data.edges.update([{id:i*matrix_data.length-1+j,from:i, to:j,color :"red",width: 3, arrows: "to"}]);
                            }else{
                                network.body.data.edges.update([{id:i*matrix_data.length-1+j,from:i, to:j,color :"red",width: 3, arrows: "from"}]);
                            }
                        }
                    }
                }

            }else{
                traffic_count = true;
                for (var i=0; i<traffic_edge.length;i++){
                    for(var j=i;j<traffic_edge.length;j++){
                        if(traffic_edge[i][j]==1){      
                            network.body.data.edges.update([{id:i*matrix_data.length-1+j,from:i, to:j,color :"#848484"}]);
                        }
                    }
                }
            }

        }

        

        /***********トラフィック関連操作************/


        function init_traffic_list(){
            for(var i=0;i<matrix_data.length;i++){
                var _list = [];
                var _arrow = [];
                for(var j=0;j<matrix_data.length;j++){
                    _list.push(0);
                    _arrow.push(0);
                }
                traffic_edge.push(_list);
                traffic_arrow.push(_arrow);
            }
            
        }

        /*トラフィックを追加*/
        function add_traffic_list(from, to){
            if(from <= to){
                traffic_edge[from-1][to-1] = 1;
                //0 → to (arrow)
                traffic_arrow[from-1][to-1] = 0;
            }else{
                traffic_edge[to-1][from-1] = 1;
                //1 → from(arrow)
                traffic_arrow[to-1][from-1] = 1;
                
            }
        }

        /*トラフィックを削除する*/
        function remove_traffic(){
            var len = edges.length;
            for (var i=0; i<traffic_edge.length;i++){
                    for(var j=i;j<traffic_edge.length;j++){
                        if(traffic_edge[i][j]==1){
                            traffic_edge[i][j] = 0;
                            network.body.data.edges.update([{id:i*matrix_data.length-1+j,color :"#848484",width: 2,arrows:{to:{ enabled: false}}}]);
                            network.body.data.edges.update([{id:i*matrix_data.length-1+j,color :"#848484",width: 2,arrows:{from:{ enabled: false}}}]);
                        }
                    }
            }
        }



         /*************ネットワークグラフを生成************/

         function init_network(){
             var container = document.getElementById("mynetwork");
             var data = {
                 nodes: nodes,
                 edges: edges,
            };
            
            var options = {
                nodes: {
                    shape: "dot",
                    size: 20,
                },
                edges:{
                    smooth: false,/*falseにすると直線になる*/
                    /*color: {
                        highlight:"#848484",
                    },*/  
                },

                //---レイアウト
               
               /* layout: {
                    hierarchical: {
                        direction: "LR", 
                        sortMethod: "directed"
                    }
                },*/
                //レイアウト

                physics: {
                    forceAtlas2Based: {
                        gravitationalConstant: -26,
                        centralGravity: 0.005,
                        springLength: 230,
                        springConstant: 0.18,
                    },
                    maxVelocity: 146,
                    solver: "forceAtlas2Based",
                    timestep: 0.35,
                },
            };
            network = new vis.Network(container, data, options);
        }


        /**次のイベント処理する**/
        function block_event(){

            if(event_data[event_id].type == "InitNode"){
                console.log(event_data[event_id].type);


            }else if(event_data[event_id].type == "FoundBlock"){
                

                update_node_found(Number(event_data[event_id].node),Number(event_data[event_id].height),event_data[event_id].hash);
                console.log(event_data[event_id].type);

            }else if(event_data[event_id].type == "ReceiveBlock"){

                node_to = Number(event_data[event_id].node);
                node_from = Number(event_data[event_id].from);
                add_traffic_list(node_from+1,node_to+1);

                
                update_node_receive(Number(event_data[event_id].node),Number(event_data[event_id].height),event_data[event_id].hash);
                console.log(event_data[event_id].type);

            }else if(event_data[event_id].type == "ReceiveTransaction"){
                console.log(event_data[event_id].type);


            }

            event_id++;
        }

    </script>


    <!--------------------------解析スケジューラ------------------------>
    <script>
        /*時計,処理の進行*/
        
        var time = 0;
        function showClock() {

            if (blockchain_data === undefined || event_data == undefined) {
                return;
            }
            if(time%60==0){
                remove_traffic();
            }
            
            time = time + 20;

            while(true){
                if(time < Number(blockchain_data[block_index].receiveTime)){
                    break;
                }
                console.log("block:"+blockchain_data[block_index].receiveTime);
                next_block();   
            }  

            while(true){
                if(time < Number(event_data[event_id].time)){
                    break;
                }
                block_event();    
            }          

           
            console.log(Number(event_data[event_id].time))
            document.getElementById("TimestampArea").innerHTML = "Simulation Time : " + time;
            
        }


        /*リピート関数*/
        function sleep(msec) {
            return new Promise(function(resolve) {
                setTimeout(function() {resolve()}, msec);
            })
        }
        async function start() {
            await sleep(150);

            //停止条件
            if(blockchain_data.length <= block_index || event_data <= event_id){
                return
            }            
            
            start();
            showClock()
           
        }

       
        async function start_traffic() {
            await sleep(300);
            play_traffic();
            start_traffic()
        }



        function main(){
            add_node();
            init_network();
            add_edge(); 
            init_traffic_list();
            start();
            start_traffic();
        }
        input_data();

    </script>

</html>